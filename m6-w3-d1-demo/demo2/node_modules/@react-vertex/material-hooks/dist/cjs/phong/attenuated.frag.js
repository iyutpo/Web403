"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
// @ts-ignore
var _default = "\n  #extension GL_OES_standard_derivatives: enable\n  precision highp float;\n\n  // This shader code was adapted from:\n  // https://github.com/stackgl/glsl-lighting-walkthrough\n\n  varying vec2 vUv;\n  varying vec3 vViewPosition;\n  varying vec3 vNormal;\n\n  float computeDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / 3.14159265;\n}\n\n  // attenuation by Tom Madams\n// Simple:\n// https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n// \n// Improved\n// https://imdoingitwrong.wordpress.com/2011/02/10/improved-light-attenuation/\n\nfloat attenuation(float r, float f, float d) {\n  float denom = d / r + 1.0;\n  float attenuation = 1.0 / (denom*denom);\n  float t = (attenuation - f) / (1.0 - f);\n  return max(t, 0.0);\n}\n\n  const float gamma_2476268529 = 2.2;\n\nfloat toLinear(float v) {\n  return pow(v, gamma_2476268529);\n}\n\nvec2 toLinear(vec2 v) {\n  return pow(v, vec2(gamma_2476268529));\n}\n\nvec3 toLinear(vec3 v) {\n  return pow(v, vec3(gamma_2476268529));\n}\n\nvec4 toLinear(vec4 v) {\n  return vec4(toLinear(v.rgb), v.a);\n}\n\n  const vec2 UV_SCALE = vec2(5.0, 5.0);\n  const float roughness = 5.0;\n  const float albedo = 2.5;\n\n  const vec3 pointLightColor = vec3(1.0);\n  const vec3 ambientLightColor = vec3(0.1);\n\n  const float lightFalloff = 0.025;\n  const float lightRadius = 10.0;\n\n  uniform sampler2D texDiff;\n\n  uniform mat4 viewMatrix;\n  uniform vec3 uLightPosition;\n\n  vec4 textureLinear(sampler2D uTex, vec2 uv) {\n    return toLinear(texture2D(uTex, uv));\n  }\n\n  void main() {\n    vec4 lightPosition = viewMatrix * vec4(uLightPosition, 1.0);\n    vec3 lightVector = lightPosition.xyz - vViewPosition;\n\n    float lightDistance = length(lightVector);\n    float falloff = attenuation(lightRadius, lightFalloff, lightDistance);\n\n    vec2 uv = vUv * UV_SCALE;\n    vec3 diffuseColor = textureLinear(texDiff, uv).rgb;\n    \n    vec3 L = normalize(lightVector);   //light direction\n    vec3 V = normalize(vViewPosition); //eye direction\n    vec3 N = vNormal;                  //surface normal\n\n    vec3 diffuse = pointLightColor * computeDiffuse(L, V, N, roughness, albedo) * falloff;\n\n    vec3 color = vec3(0.0);\n    color += diffuseColor * (diffuse + ambientLightColor);\n\n    gl_FragColor.rgb = color;\n    gl_FragColor.a = 1.0;\n  }\n";
exports["default"] = _default;
//# sourceMappingURL=attenuated.frag.js.map