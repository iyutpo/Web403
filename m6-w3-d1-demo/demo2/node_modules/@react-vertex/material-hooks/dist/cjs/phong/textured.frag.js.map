{"version":3,"sources":["../../../src/phong/textured.frag.ts"],"names":[],"mappings":";;;;;;AAAA","sourcesContent":["// @ts-ignore\nimport glsl from 'glslify'\n\nexport default glsl`\n  precision <<FLOAT_PRECISION>> float;\n\n  uniform vec3 uKa;\n  uniform float uNa;\n  uniform vec3 uKs;\n  uniform float uNs;\n  uniform sampler2D mapKd;\n  uniform vec2 uVScale;\n\n  const int NUM_POINT_LIGHTS = <<NUM_POINT_LIGHTS>>;\n  uniform vec3 pointLd[NUM_POINT_LIGHTS];\n  \n  varying vec3 vNormal;\n  varying vec2 vUv;\n  varying vec3 vEye;\n  varying vec3 vRay[NUM_POINT_LIGHTS];\n    \n  #pragma glslify: toLinear = require('glsl-gamma/in')\n\n  vec4 textureLinear(sampler2D uTex, vec2 uv) {\n    return toLinear(texture2D(uTex, uv));\n  }\n\n  void main() {\n    vec2 uv = vUv * uVScale;\n    vec3 kd = textureLinear(mapKd, uv).rgb;\n    \n    vec3 color = vec3(0.0);\n    vec3 light = vec3(0.0);\n    vec3 eye = normalize(vEye);\n    vec3 reflection = vec3(0.0);\n    vec3 normal = normalize(vNormal);\n    vec3 ambient = kd * uKa * uNa;\n\n    for (int i = 0; i < NUM_POINT_LIGHTS; i++) {\n      light = normalize(vRay[i]);\n      reflection = reflect(light, normal);\n      color += (pointLd[i] * kd * clamp(dot(normal, -light), 0.0, 1.0));\n      color += (uKs * pow(max(dot(reflection, eye), 0.0), uNs) * 1.0);\n    }\n\n    gl_FragColor = vec4(color + ambient, 1.0);\n  }\n`\n"],"file":"textured.frag.js"}