{"version":3,"sources":["../../../src/phong/attenuated.frag.ts"],"names":[],"mappings":";;;;;;AAAA","sourcesContent":["// @ts-ignore\nimport glsl from 'glslify'\n\nexport default glsl`\n  #extension GL_OES_standard_derivatives: enable\n  precision highp float;\n\n  // This shader code was adapted from:\n  // https://github.com/stackgl/glsl-lighting-walkthrough\n\n  varying vec2 vUv;\n  varying vec3 vViewPosition;\n  varying vec3 vNormal;\n\n  #pragma glslify: computeDiffuse = require('glsl-diffuse-oren-nayar')\n  #pragma glslify: attenuation = require('./attenuation')\n  #pragma glslify: toLinear = require('glsl-gamma/in')\n\n  const vec2 UV_SCALE = vec2(5.0, 5.0);\n  const float roughness = 5.0;\n  const float albedo = 2.5;\n\n  const vec3 pointLightColor = vec3(1.0);\n  const vec3 ambientLightColor = vec3(0.1);\n\n  const float lightFalloff = 0.025;\n  const float lightRadius = 10.0;\n\n  uniform sampler2D texDiff;\n\n  uniform mat4 viewMatrix;\n  uniform vec3 uLightPosition;\n\n  vec4 textureLinear(sampler2D uTex, vec2 uv) {\n    return toLinear(texture2D(uTex, uv));\n  }\n\n  void main() {\n    vec4 lightPosition = viewMatrix * vec4(uLightPosition, 1.0);\n    vec3 lightVector = lightPosition.xyz - vViewPosition;\n\n    float lightDistance = length(lightVector);\n    float falloff = attenuation(lightRadius, lightFalloff, lightDistance);\n\n    vec2 uv = vUv * UV_SCALE;\n    vec3 diffuseColor = textureLinear(texDiff, uv).rgb;\n    \n    vec3 L = normalize(lightVector);   //light direction\n    vec3 V = normalize(vViewPosition); //eye direction\n    vec3 N = vNormal;                  //surface normal\n\n    vec3 diffuse = pointLightColor * computeDiffuse(L, V, N, roughness, albedo) * falloff;\n\n    vec3 color = vec3(0.0);\n    color += diffuseColor * (diffuse + ambientLightColor);\n\n    gl_FragColor.rgb = color;\n    gl_FragColor.a = 1.0;\n  }\n`\n"],"file":"attenuated.frag.js"}