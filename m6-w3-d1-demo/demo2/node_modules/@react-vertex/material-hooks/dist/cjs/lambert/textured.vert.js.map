{"version":3,"sources":["../../../src/lambert/textured.vert.ts"],"names":[],"mappings":";;;;;;AAAA","sourcesContent":["// @ts-ignore\nimport glsl from 'glslify'\n\nexport default glsl`\n  precision <<FLOAT_PRECISION>> float;\n\n  uniform mat4 viewMatrix;\n  uniform mat4 modelMatrix;\n  uniform mat4 projectionMatrix;\n\n  const int NUM_POINT_LIGHTS = <<NUM_POINT_LIGHTS>>;\n  uniform vec3 pointLd[NUM_POINT_LIGHTS];\n  uniform vec3 pointLp[NUM_POINT_LIGHTS];\n\n  uniform sampler2D mapKd;\n  uniform vec2 uVScale;\n  uniform vec3 uKa;\n  uniform float uNa;\n\n  attribute vec3 position;\n  attribute vec3 normal;\n  attribute vec2 uv;\n\n  varying vec3 vColor;\n\n  #pragma glslify: transpose = require('glsl-transpose')\n  #pragma glslify: inverse = require('glsl-inverse')\n  #pragma glslify: toLinear = require('glsl-gamma/in')\n\n  vec4 textureLinear(sampler2D uTex, vec2 uv) {\n    return toLinear(texture2D(uTex, uv));\n  }\n\n  void main(void) {\n    vec3 kd = textureLinear(mapKd, uv * uVScale).rgb;\n\n    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n    vec4 viewModelPosition = modelViewMatrix * vec4(position, 1.0);\n  \n    mat3 normalMatrix = transpose(inverse(mat3(modelViewMatrix)));\n    vec3 N = normalize(normalMatrix * normal);\n\n    vec3 color = vec3(0.0);\n    vec3 light = vec3(0.0);\n    vec4 lightPosition = vec4(0.0);\n    vec3 ambient = kd * uKa * uNa;\n\n    for (int i = 0; i < NUM_POINT_LIGHTS; i++) {\n      lightPosition = viewMatrix * vec4(pointLp[i], 1.0);\n      light = -normalize(viewModelPosition.xyz - lightPosition.xyz);\n      color += (pointLd[i] * kd * clamp(dot(N, light), 0.0, 1.0));\n    }\n\n    vColor = color + ambient;\n\n    gl_Position = projectionMatrix * viewModelPosition;\n  }\n`\n"],"file":"textured.vert.js"}