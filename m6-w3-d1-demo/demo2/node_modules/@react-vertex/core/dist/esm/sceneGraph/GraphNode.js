import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import { mat4 } from 'gl-matrix';
import { SceneNode } from './SceneNode';
export var isGraphNode = Symbol('isGraphNode');

var GraphNode = /*#__PURE__*/function () {
  function GraphNode() {
    _classCallCheck(this, GraphNode);

    this.parent = void 0;
    this.children = void 0;
    this.matrix = void 0;
    this.worldMatrix = void 0;
    this.needsMatrixUpdate = void 0;
    this.userManagedMatrix = void 0;
    this.position = void 0;
    this.rotation = void 0;
    this.scale = void 0;
    this.root = void 0;
    this[isGraphNode] = true;
    this.children = [];
    this.matrix = mat4.create();
    this.worldMatrix = mat4.create();
    this.needsMatrixUpdate = false;
    this.userManagedMatrix = false;
  }

  _createClass(GraphNode, [{
    key: "add",
    value: function add(child) {
      child.parent = this;
      child.updateWorldMatrix();
      this.children.push(child);
    }
  }, {
    key: "remove",
    value: function remove(child) {
      var index = this.children.findIndex(function (d) {
        return d === child;
      });

      if (index >= 0) {
        delete this.children[index].parent;
        this.children.splice(index, 1);
      }
    }
  }, {
    key: "updateWorldMatrix",
    value: function updateWorldMatrix() {
      if (this instanceof SceneNode) {
        mat4.copy(this.worldMatrix, this.matrix);
      } else if (this.parent) {
        mat4.multiply(this.worldMatrix, this.parent.worldMatrix, this.matrix);
      }
    }
  }, {
    key: "updateMatrix",
    value: function updateMatrix() {
      if (this.userManagedMatrix) {
        return;
      }

      mat4.identity(this.matrix);

      if (this.position) {
        mat4.translate(this.matrix, this.matrix, this.position);
      }

      if (this.rotation) {
        var _this$rotation = _slicedToArray(this.rotation, 3),
            x = _this$rotation[0],
            y = _this$rotation[1],
            z = _this$rotation[2];

        x && mat4.rotateX(this.matrix, this.matrix, x);
        y && mat4.rotateY(this.matrix, this.matrix, y);
        z && mat4.rotateZ(this.matrix, this.matrix, z);
      }

      if (this.scale) {
        mat4.scale(this.matrix, this.matrix, this.scale);
      }
    }
  }, {
    key: "applyMatrixProps",
    value: function applyMatrixProps(nextprops, prevProps) {
      if (nextprops.matrix) {
        this.matrix = nextprops.matrix;
        this.userManagedMatrix = true;
        this.updateWorldMatrix();
        this.children.forEach(function (c) {
          return c.needsMatrixUpdate = true;
        });
      } else if (nextprops.position !== prevProps.position || nextprops.rotation !== prevProps.rotation || nextprops.scale !== prevProps.scale) {
        this.position = nextprops.position;
        this.rotation = nextprops.rotation;
        this.scale = nextprops.scale;
        this.needsMatrixUpdate = true;
      }

      if (this.root && this.root.renderOnUpdate) {
        this.root.requestRender();
      }
    }
  }]);

  return GraphNode;
}();

export { GraphNode as default };
//# sourceMappingURL=GraphNode.js.map