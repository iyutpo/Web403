import { useMemo } from 'react';
import { useWebGLVersion } from '../hooks';
export function useAttribute(gl, size, buffer, getOptions) {
  var memoized = useMemo(function () {
    return function (location) {
      if (location >= 0) {
        var options = getOptions ? getOptions(gl) : {};
        var target = options.target || gl.ARRAY_BUFFER;
        gl.enableVertexAttribArray(location);
        gl.bindBuffer(target, buffer);
        var type = options.type || gl.FLOAT;
        var normalized = options.normalized || false;
        var stride = options.stride || 0;
        var offset = options.offset || 0;
        gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
      }
    };
  }, [gl, size, buffer, getOptions]);
  return memoized;
}
export function useInstancedAttribute(gl, size, buffer, getOptions) {
  var version = useWebGLVersion();
  var memoized = useMemo(function () {
    return function (location, ext) {
      if (location >= 0) {
        var options = getOptions ? getOptions(gl) : {};
        var target = options.target || gl.ARRAY_BUFFER;
        gl.enableVertexAttribArray(location);
        gl.bindBuffer(target, buffer);
        var type = options.type || gl.FLOAT;
        var normalized = options.normalized || false;
        var stride = options.stride || 0;
        var offset = options.offset || 0;
        gl.vertexAttribPointer(location, size, type, normalized, stride, offset);

        if (version === 2) {
          // @ts-ignore
          gl.vertexAttribDivisor(location, 1);
        } else if (ext) {
          ext.vertexAttribDivisorANGLE(location, 1);
        } else {
          console.log('Instanced attributes require WebGL 2 or ANGLE extension');
        }
      }
    };
  }, [gl, size, buffer, version, getOptions]);
  return memoized;
}
//# sourceMappingURL=attributes.js.map