import { useMemo, useEffect } from 'react';
import warn from 'warning';
var prefix = 'react-vertex:';

function log(source) {
  if (typeof source !== 'string') {
    warn(false, "".concat(prefix, " Shader source should be a string!"));
    return '';
  }

  var lines = source.split('\n');

  for (var i = 0; i < lines.length; i++) {
    lines[i] = i + 1 + ': ' + lines[i];
  }

  return lines.join('\n');
}

function useShader(gl, source) {
  var isVertShader = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var memoized = useMemo(function () {
    var _gl$getShaderPrecisio, _gl$getShaderPrecisio2;

    if (source.constructor === WebGLShader) {
      return source;
    }

    var shaderType = isVertShader ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER;
    var shader = gl.createShader(shaderType);
    var precision = 'lowp'; // prettier-ignore

    if ((_gl$getShaderPrecisio = gl.getShaderPrecisionFormat(shaderType, gl.HIGH_FLOAT)) !== null && _gl$getShaderPrecisio !== void 0 && _gl$getShaderPrecisio.precision || 0 > 0) {
      precision = 'highp';
    } else if ((_gl$getShaderPrecisio2 = gl.getShaderPrecisionFormat(shaderType, gl.MEDIUM_FLOAT)) !== null && _gl$getShaderPrecisio2 !== void 0 && _gl$getShaderPrecisio2.precision || 0 > 0) {
      precision = 'mediump';
    }

    var prepped = source.replace('<<FLOAT_PRECISION>>', precision);

    if (shader) {
      gl.shaderSource(shader, prepped);
      gl.compileShader(shader);
      warn(gl.getShaderParameter(shader, gl.COMPILE_STATUS), "".concat(prefix, "\n").concat(gl.getShaderInfoLog(shader), "\n").concat(log(prepped)));
    } else {
      warn(false, "".concat(prefix, "\nShader could not be compiled. Source:\n").concat(source));
    }

    return shader;
  }, [gl, source, isVertShader]);
  return memoized;
}

export function useProgram(gl, vertSource, fragSource) {
  var vert = useShader(gl, vertSource, true);
  var frag = useShader(gl, fragSource, false);
  var memoized = useMemo(function () {
    var program = gl.createProgram();

    if (program && vert && frag) {
      gl.attachShader(program, vert);
      gl.attachShader(program, frag);
      gl.linkProgram(program);
      warn(gl.getProgramParameter(program, gl.LINK_STATUS), "".concat(prefix, " Error creating program"));
    } else {
      throw Error('Program could not be created.');
    }

    return program;
  }, [gl, vert, frag]);
  useEffect(function () {
    return function () {
      return gl.deleteProgram(memoized);
    };
  }, [gl, memoized]);
  gl.useProgram(memoized);
  return memoized;
}
export function useProgramUniforms(gl, program) {
  var memoized = useMemo(function () {
    var uniforms = {};
    var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

    for (var i = 0; i < uniformCount; i++) {
      var _gl$getActiveUniform;

      var _name = (_gl$getActiveUniform = gl.getActiveUniform(program, i)) === null || _gl$getActiveUniform === void 0 ? void 0 : _gl$getActiveUniform.name;

      if (_name) {
        uniforms[_name] = gl.getUniformLocation(program, _name);
      }
    }

    return uniforms;
  }, [gl, program]);
  return memoized;
}
//# sourceMappingURL=shaders.js.map