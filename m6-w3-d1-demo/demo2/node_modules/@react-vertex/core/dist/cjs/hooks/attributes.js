"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAttribute = useAttribute;
exports.useInstancedAttribute = useInstancedAttribute;

var _react = require("react");

function useAttribute(gl, size, buffer, getOptions) {
  var memoized = (0, _react.useMemo)(function () {
    return function (location) {
      if (location >= 0) {
        var options = getOptions ? getOptions(gl) : {};
        var target = options.target || gl.ARRAY_BUFFER;
        gl.enableVertexAttribArray(location);
        gl.bindBuffer(target, buffer);
        var type = options.type || gl.FLOAT;
        var normalized = options.normalized || false;
        var stride = options.stride || 0;
        var offset = options.offset || 0;
        gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
      }
    };
  }, [gl, size, buffer, getOptions]);
  return memoized;
}

function useInstancedAttribute(gl, size, buffer, getOptions) {
  var memoized = (0, _react.useMemo)(function () {
    return function (location, ext) {
      if (location >= 0) {
        var options = getOptions ? getOptions(gl) : {};
        var target = options.target || gl.ARRAY_BUFFER;
        gl.enableVertexAttribArray(location);
        gl.bindBuffer(target, buffer);
        var type = options.type || gl.FLOAT;
        var normalized = options.normalized || false;
        var stride = options.stride || 0;
        var offset = options.offset || 0;
        gl.vertexAttribPointer(location, size, type, normalized, stride, offset);

        if (gl instanceof WebGL2RenderingContext) {
          gl.vertexAttribDivisor(location, 1);
        } else if (ext) {
          ext.vertexAttribDivisorANGLE(location, 1);
        } else {
          console.log('Instanced attributes require WebGL 2 or ANGLE extension');
        }
      }
    };
  }, [gl, size, buffer, getOptions]);
  return memoized;
}
//# sourceMappingURL=attributes.js.map