"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  ctxErr: true,
  useRender: true,
  useWebGLContext: true,
  useWebGLVersion: true,
  useSceneNode: true,
  useCanvas: true,
  useCanvasSize: true
};
exports.useRender = useRender;
exports.useWebGLContext = useWebGLContext;
exports.useWebGLVersion = useWebGLVersion;
exports.useSceneNode = useSceneNode;
exports.useCanvas = useCanvas;
exports.useCanvasSize = useCanvasSize;
exports.ctxErr = void 0;

var _react = require("react");

var _Context = _interopRequireDefault(require("../Context"));

var _shaders = require("./shaders");

Object.keys(_shaders).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _shaders[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _shaders[key];
    }
  });
});

var _buffers = require("./buffers");

Object.keys(_buffers).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _buffers[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _buffers[key];
    }
  });
});

var _framebuffers = require("./framebuffers");

Object.keys(_framebuffers).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _framebuffers[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _framebuffers[key];
    }
  });
});

var _lights = require("./lights");

Object.keys(_lights).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _lights[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _lights[key];
    }
  });
});

var _attributes = require("./attributes");

Object.keys(_attributes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _attributes[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _attributes[key];
    }
  });
});

var _uniforms = require("./uniforms");

Object.keys(_uniforms).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _uniforms[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _uniforms[key];
    }
  });
});

var _textures = require("./textures");

Object.keys(_textures).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _textures[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _textures[key];
    }
  });
});
var ctxErr = 'hook must be used in a React Vertex component tree.';
exports.ctxErr = ctxErr;

function useRender() {
  var context = (0, _react.useContext)(_Context["default"]);

  if (!context) {
    throw Error("useRender ".concat(ctxErr));
  }

  if (!context.scene) {
    throw Error('The scene is not on the context.');
  }

  return context.scene.render;
}

function useWebGLContext() {
  var context = (0, _react.useContext)(_Context["default"]);

  if (!context) {
    throw new Error("useWebGLContext ".concat(ctxErr));
  }

  if (!context.scene) {
    throw Error('The scene is not on the context.');
  }

  return context.scene.context;
}

function useWebGLVersion() {
  var context = (0, _react.useContext)(_Context["default"]);

  if (!context) {
    throw new Error("useWebGLVersion ".concat(ctxErr));
  }

  if (!context.scene) {
    throw Error('The scene is not on the context.');
  }

  return context.scene.webglVersion;
}

function useSceneNode() {
  var context = (0, _react.useContext)(_Context["default"]);

  if (!context.scene) {
    throw Error('The scene is not on the context.');
  }

  return context.scene;
}

function useCanvas() {
  var context = (0, _react.useContext)(_Context["default"]);

  if (!context) {
    throw new Error("useCanvas ".concat(ctxErr));
  }

  if (!context.scene) {
    throw Error('The scene is not on the context.');
  }

  return context.scene.element;
}

function useCanvasSize() {
  var context = (0, _react.useContext)(_Context["default"]);

  if (!context) {
    throw new Error("useCanvasSize ".concat(ctxErr));
  }

  if (!context.scene) {
    throw Error('The scene is not on the context.');
  }

  var memoized = (0, _react.useMemo)(function () {
    var _context$scene, _context$scene2;

    return {
      width: context.width,
      clientWidth: ((_context$scene = context.scene) === null || _context$scene === void 0 ? void 0 : _context$scene.element.clientWidth) || context.width,
      height: context.height,
      clientHeight: ((_context$scene2 = context.scene) === null || _context$scene2 === void 0 ? void 0 : _context$scene2.element.clientHeight) || context.height
    };
  }, [context.width, context.height, context.scene.element]);
  return memoized;
}
//# sourceMappingURL=index.js.map