"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTypedArray = useTypedArray;
exports.useBuffer = useBuffer;
exports.useStaticBuffer = useStaticBuffer;
exports.useStreamBuffer = useStreamBuffer;
exports.useDyanmicBuffer = useDyanmicBuffer;

var _react = require("react");

var _warning = _interopRequireDefault(require("warning"));

var prefix = 'react-vertex:';

function useTypedArray(data, format) {
  var memoized = (0, _react.useMemo)(function () {
    var contents;

    if (format && typeof format === 'string') {
      switch (format.toUpperCase()) {
        case 'U8':
          contents = Uint8Array.from(data);
          break;

        case 'U16':
          contents = Uint16Array.from(data);
          break;

        case 'U32':
          contents = Uint32Array.from(data);
          break;

        case 'I8':
          contents = Int8Array.from(data);
          break;

        case 'I16':
          contents = Int16Array.from(data);
          break;

        case 'I32':
          contents = Int32Array.from(data);
          break;

        case 'F32':
          contents = Float32Array.from(data);
          break;
      }
    }

    if (!contents) {
      if (data instanceof Uint8Array || data instanceof Uint16Array || data instanceof Uint32Array || data instanceof Int8Array || data instanceof Int16Array || data instanceof Int32Array || data instanceof Float32Array) {
        return data;
      } else {
        throw Error('Undable to return typed array instance.');
      }
    }

    return contents;
  }, [data, format]);
  return memoized;
}

function useBuffer(gl, data) {
  var isIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var format = arguments.length > 3 ? arguments[3] : undefined;
  var usage = arguments.length > 4 ? arguments[4] : undefined;
  var contents = useTypedArray(data, format);
  var memoized = (0, _react.useMemo)(function () {
    var buffer = gl.createBuffer();
    (0, _warning["default"])(!!buffer, "".concat(prefix, " Failed to create buffer."));
    return buffer;
  }, [gl]);
  (0, _react.useMemo)(function () {
    if (isIndex) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, memoized);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, contents, usage);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    } else {
      gl.bindBuffer(gl.ARRAY_BUFFER, memoized);
      gl.bufferData(gl.ARRAY_BUFFER, contents, usage);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
  }, [gl, isIndex, usage, contents, memoized]);
  (0, _react.useEffect)(function () {
    return function () {
      gl.isBuffer(memoized) && gl.deleteBuffer(memoized);
    };
  }, [gl, memoized]);
  return memoized;
}

function useStaticBuffer(gl, data) {
  var isIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var format = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  return useBuffer(gl, data, isIndex, format, gl.STATIC_DRAW);
}

function useStreamBuffer(gl, data) {
  var isIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var format = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  return useBuffer(gl, data, isIndex, format, gl.STREAM_DRAW);
}

function useDyanmicBuffer(gl, data) {
  var isIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var format = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  return useBuffer(gl, data, isIndex, format, gl.DYNAMIC_DRAW);
}
//# sourceMappingURL=buffers.js.map