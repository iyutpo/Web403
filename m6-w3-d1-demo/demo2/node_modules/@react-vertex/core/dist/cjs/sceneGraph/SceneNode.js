"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SceneNode = exports.isSceneNode = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _lodash = _interopRequireDefault(require("lodash.throttle"));

var _warning = _interopRequireDefault(require("warning"));

var _GraphNode = _interopRequireDefault(require("./GraphNode"));

var _ = require(".");

var _lights = require("../lights");

var _CameraNode = require("./CameraNode");

var _GeometryNode = require("./GeometryNode");

var _InstancedNode = require("./InstancedNode");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var isSceneNode = Symbol('isSceneNode');
exports.isSceneNode = isSceneNode;

function getMode(gl, modeString) {
  if (!modeString) {
    return gl.TRIANGLES;
  }

  switch (modeString) {
    case 'TRIANGLES':
      return gl.TRIANGLES;

    case 'LINES':
      return gl.LINES;

    case 'POINTS':
      return gl.POINTS;

    case 'LINE_STRIP':
      return gl.LINE_STRIP;

    case 'LINE_LOOP':
      return gl.LINE_LOOP;

    case 'TRIANGLE_STRIP':
      return gl.TRIANGLE_STRIP;

    case 'TRIANGLE_FAN':
      return gl.TRIANGLE_FAN;

    default:
      return gl.TRIANGLES;
  }
}

var SceneNode = /*#__PURE__*/function (_Node) {
  (0, _inherits2["default"])(SceneNode, _Node);

  var _super = _createSuper(SceneNode);

  function SceneNode(canvas, extensions, _gl) {
    var _this;

    (0, _classCallCheck2["default"])(this, SceneNode);
    _this = _super.call(this);
    _this.context = void 0;
    _this.element = void 0;
    _this.maxTextures = void 0;
    _this.extensions = void 0;
    _this[isSceneNode] = true;
    _this.renderOnUpdate = false;
    _this.webglVersion = 1;
    _this.pointLights = new _lights.PointLights();
    _this.clearColor = [0, 0, 0, 0];
    _this.textureUnits = {};
    _this.materialMap = new WeakMap();
    _this.activeAttribCount = 0;
    _this.activeAttributes = null;

    _this.render = function () {
      var gl = _this.context;
      gl.enable(gl.DEPTH_TEST);
      gl.clearColor.apply(gl, (0, _toConsumableArray2["default"])(_this.clearColor));
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      Object.keys(_this.textureUnits).forEach(function (unit) {
        if (_this.textureUnits[unit] !== false) {
          /* @ts-ignore */
          gl.activeTexture(gl["TEXTURE".concat(unit)]);
          gl.bindTexture(gl.TEXTURE_2D, _this.textureUnits[unit]);
        }
      });
      var needsMatrixUpdate = _this.needsMatrixUpdate === true;

      if (needsMatrixUpdate) {
        _this.updateMatrix();

        _this.updateWorldMatrix();

        _this.needsMatrixUpdate = false;
      }

      for (var i = 0; i < _this.children.length; i++) {
        _this.renderNode(_this.children[i], null, null, needsMatrixUpdate);
      }
    };

    _this.requestRender = (0, _lodash["default"])(_this.render, 17);
    _this.context = _gl;
    _this.element = canvas;
    _this.maxTextures = _gl.getParameter(_gl.MAX_TEXTURE_IMAGE_UNITS);
    _this.extensions = extensions.reduce(function (acc, ext) {
      acc[ext] = _gl.getExtension(ext);
      return acc;
    }, {});
    return _this;
  }

  (0, _createClass2["default"])(SceneNode, [{
    key: "getTextureUnit",
    value: function getTextureUnit(texture) {
      for (var _unit = 0; _unit < this.maxTextures; _unit++) {
        if (this.textureUnits[_unit] === undefined) {
          this.textureUnits[_unit] = texture || false;
          return _unit;
        }
      }

      (0, _warning["default"])(false, "Max textures(".concat(this.maxTextures, ") exceeded."));
      return this.maxTextures - 1;
    }
  }, {
    key: "releaseTextureUnit",
    value: function releaseTextureUnit(unit) {
      delete this.textureUnits[unit];
    }
  }, {
    key: "setMaterial",
    value: function setMaterial(gl, _ref) {
      var program = _ref.program;

      if (!program) {
        throw Error('Encountered material with no program.');
      }

      var material = this.materialMap.get(program);

      if (material) {
        return material;
      }

      var attributes = {};
      var attribCount = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

      for (var i = attribCount - 1; i >= 0; i--) {
        var attr = gl.getActiveAttrib(program, i);

        if (attr) {
          attributes[attr.name] = gl.getAttribLocation(program, attr.name);
        } else {
          (0, _warning["default"])(false, 'Encountered invalid attribute index.');
        }
      }

      var uniforms = {
        v: gl.getUniformLocation(program, 'viewMatrix'),
        m: gl.getUniformLocation(program, 'modelMatrix'),
        p: gl.getUniformLocation(program, 'projectionMatrix')
      };
      material = {
        program: program,
        uniforms: uniforms,
        attributes: attributes,
        attribCount: attribCount
      };
      this.materialMap.set(program, material);
      return material;
    }
  }, {
    key: "renderNode",
    value: function renderNode(node, activeCamera, activeMaterial, needsMatrixUpdate) {
      var gl = this.context; // *************************************************
      // UPDATE MATRIX IF NEEDED
      // *************************************************

      needsMatrixUpdate = needsMatrixUpdate || node.needsMatrixUpdate === true;

      if (needsMatrixUpdate) {
        node.updateMatrix();
        node.updateWorldMatrix();
        node.needsMatrixUpdate = false;
      } // *************************************************
      // HANDLE CAMERA
      // *************************************************


      if (node instanceof _CameraNode.CameraNode) {
        activeCamera = node;
      } // *************************************************
      // HANDLE MATERIAL
      // *************************************************


      if (node instanceof _.MaterialNode) {
        var nextMaterial = this.setMaterial(gl, node); // note: buffers are deleted when no longer in use by the buffer
        // hooks. So we to disable attribute indexes no longer in use or it
        // will throw an error about no buffer being bound to the index.

        var diff = this.activeAttribCount - nextMaterial.attribCount;

        if (diff > 0) {
          for (var i = 0; i < diff; i++) {
            gl.disableVertexAttribArray(nextMaterial.attribCount + i);
          }
        }

        this.activeAttribCount = nextMaterial.attribCount;
        this.activeAttributes = null;
        activeMaterial = nextMaterial;
        gl.useProgram(activeMaterial.program);

        if (activeCamera) {
          var _activeCamera = activeCamera,
              view = _activeCamera.view,
              projection = _activeCamera.projection;
          gl.uniformMatrix4fv(activeMaterial.uniforms.v, false, view);
          gl.uniformMatrix4fv(activeMaterial.uniforms.p, false, projection);
        }
      } // *************************************************
      // HANDLE GEOMETRY
      // *************************************************


      if (node instanceof _GeometryNode.GeometryNode) {
        if (activeMaterial) {
          gl.useProgram(activeMaterial.program);

          if (node.attributes !== this.activeAttributes) {
            for (var attr in activeMaterial.attributes) {
              var location = activeMaterial.attributes[attr];
              node.attributes[attr](location);
            }

            this.activeAttributes = node.attributes;
          }

          gl.uniformMatrix4fv(activeMaterial.uniforms.m, false, node.worldMatrix);

          if (node.drawArrays) {
            gl.drawArrays(getMode(gl, node.drawArrays.mode), node.drawArrays.first || 0, node.drawArrays.count);
          } else if (node.drawElements) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, node.index);
            gl.drawElements(getMode(gl, node.drawElements.mode), node.drawElements.count, node.drawElements.type ? // @ts-ignore
            gl[node.drawElements.type] : gl.UNSIGNED_SHORT, node.drawElements.offset || 0);
          }

          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
      } // *************************************************
      // HANDLE INSTANCED GEOMETRY
      // *************************************************


      if (node instanceof _InstancedNode.InstancedNode) {
        if (activeMaterial) {
          gl.useProgram(activeMaterial.program);

          if (this.extensions[_.instancedExt] === undefined) {
            this.extensions[_.instancedExt] = gl.getExtension(_.instancedExt);
          }

          var ext = this.extensions[_.instancedExt];

          if (node.attributes !== this.activeAttributes) {
            for (var _attr in activeMaterial.attributes) {
              var _location = activeMaterial.attributes[_attr];

              node.attributes[_attr](_location, ext, this.webglVersion);
            }

            this.activeAttributes = node.attributes;
          }

          gl.uniformMatrix4fv(activeMaterial.uniforms.m, false, node.worldMatrix);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, node.index);

          if (gl instanceof WebGL2RenderingContext && node.drawElements) {
            gl.drawElementsInstanced(getMode(gl, node.drawElements.mode), node.drawElements.count, node.drawElements.type ? // @ts-ignore
            gl[node.drawElements.type] : gl.UNSIGNED_SHORT, node.drawElements.offset || 0, node.drawElements.primcount);
          } else if (node.drawElements) {
            ext.drawElementsInstancedANGLE(getMode(gl, node.drawElements.mode), node.drawElements.count, node.drawElements.type ? // @ts-ignore
            gl[node.drawElements.type] : gl.UNSIGNED_SHORT, node.drawElements.offset || 0, node.drawElements.primcount);
          }

          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
      }

      for (var _i = 0; _i < node.children.length; _i++) {
        this.renderNode(node.children[_i], activeCamera, activeMaterial, needsMatrixUpdate);
      }
    }
  }]);
  return SceneNode;
}(_GraphNode["default"]);

exports.SceneNode = SceneNode;
//# sourceMappingURL=SceneNode.js.map